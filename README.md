# Trade better than your friends!
#### Video Demo: https://youtu.be/LQxyIAEMgSQ
#### Description:
In this final project for CS50's Introduction to Computer Science, we, Mark Marner-Hausen and Lennart Struth, built a web application that simulates a stock trading app. The app builds on the final problem set of the course but comes with significant extensions and refinements. In particular, it allows the individual user not only to take long positions, but also to hold short positions, and furthermore to compare their own performance with that of friends who also use the app. In this respect, the app can serve an educational purpose, firstly because it allows users to experiment with complex trading strategies without the risk of losing money, and secondly, because it offers the opportunity to rank one's own performance relative to other users. The latter can counteract overconfidence, a falacy that plays a significant role in financial market literature. On a more technical level, we avoided using CS50's SQL library by developing a class that handles DB connection and query execution for specific parameters, and we added graphical visualizations for the performance of individual stocks as well as the performance of one's own portfolio. 

In the following sections, we will explain the project in more detail. The description will cover the additional features and highlight the differences in implementation compared to the CS50 Finance web application of the final problem set.


##### New data source: Finnhub API
In the Pset we were using IEX as the source for data on current stock prices. We chose to use a different source and implemented helper functions to connect to the Finnhub API. This has several advantages:
First, the free version is not limited to a 30-day period as is IEX.
Second, Finnhub allows to not only get the current price, but also to get data on stock candles, that is, a number of prices (open, close, high, low) for a given time period.
Third, Finnhub provides historical data (up to 1 year in the past) in the free version. This allows to calculate the value of derivatives that depend on past prices. We use this in our implementation of short selling and our adjustment of the get quote functionality.


##### Helper functions
We implemented a few additional helper functions. First, we had to implement a function that connects to the Finnhub API to get quotes for stocks. Second, we implemented an additional function that gets stock candles from the Finnhub API. This function takes as argument the symbol as well as a date (as unix time stamp) for the candle. The function then requests the candle for the full day and returns the close price (if existing) or the open price. Since on weekends there is no trading data, the function is implemented to return data on the next working day (Monday). Third, we implemented functions to convert dates from the SQL databases to UNIX time stamps in order to be able to compare time stamps as well as use these as input for the API reqests.


##### Avoiding CS50's SQL Library
The db_connect.py script manages the connection and execution of queries on our DB named database_project.db. For our purposes, it functions similarly to the CS50 SQL library. Upon initialization, the class opens and closes a connection to the database whenever the execute function is called. In doing so, it ensures that any connections that are opened are also closed. In addition, it allows you to specify queries with parameters, but unlike the CS50 SQL library, the parameters must be tuples.


##### Quote and Quoted Customization 
Similar to the last p-set, users can get information on stock prices by looking up the respective symbol. Beyond the current stock price, our app provides the user with a candlestick plot of the stock's price trend for the past year. That is, all days with closing price < opening price are shown in red, while days with closing price > opening price are shown in green. The vertical extent of each candle shows how far apart the opening and closing prices are. Besides providing additional information, we decided to implement this feature because we found the underlying technicalities interesting. Not only did we need to process the data provided by Finnhub to create the corresponding candlestick plot, but also to temporarily store the image, encode it and convert it into a data URI to make it visible in our app.


##### Short selling
We implemented a feature that is similar to short selling in the real financial market. We have not implemented a margin account, potentially margin calls etc, but decided to implement a simpler version that is similar in the idea of short selling. More specifically, we decided to have the user, when deciding to go short on a stock, specify a date at which the user has to buy the stocks back. Hence, "short selling" in our app goes by the following: The user decides on a stock and the number of shares, the user borrows these shares (for free) and sells them at the current market price. At the same time the user has to specify a date in the future at which the user wants to buy back the shares from the market at the corresponding market price. This is not exactly as short selling works in the real financial market but it implements the same idea, namely that it is possible to insure against a decrease in a stock's value.
We decided to go for this implementation as it is interesting from a technical point of view. In order to calculate the profit from short positions we need to obtain the value of a stock at the specified rebuy date. This is done in the following way: When "buying" a short position, the order is listed on the index page as an open short order. Whenever reloading the index page, in the backend all open short positions for which the rebuy date has passed since the last time the site was refreshed are closed. That is, the price for the rebuy date (at this point in time it might actually be a few days in the past), is obtained from the Finnhub API, and the profit/loss from the short position is calculated. To implement this in the backend we had to create additional tables in the data base in order to keep track of the open short orders at any given date and update the table accordingly whenever any user requests the index page.


##### Portfolio customization and history review.
In light of the new functionality described so far, we needed to customize the index page and the history page. In addition to showing all open long positions, the index page now also contains a list of all open short positions. Short positions are evaluated at the current price to present performance feedback to the user in the form of the "Current (unrealized) Profit", i.e. the profit the user would make if the short position would be closed at this moment. In addition to all long buy and sell orders, the history page now contains records of all executed short orders. Finally, the index page was enhanced with a chart that provides users with a timeline of their realized profit as a percentage of their total cash inflows. For this, we had to adjust the backend so that every cash raised by a user is captured in the data. This allows us to calculate the total amount of cash taken in. The graph only deals with the realized profits, which is straightforward for short positions. For long positions, each sale is valued at the average buy price in case the user does not sell the entire holding of a particular stock. The graph shows a scatter plot with red dots if the performance is negative and green dots if it is positive. The underlying technique works similarly to the candlestick plot described above. The realized profit as a percentage of total cash inflows is the basis for our leaderboard, the final innovation described below.  


##### Leaderboard
Users have access to a leaderboard where all users are ranked by their profit as a percentage of total cash intake. We could not use the total value of the portfolio as a measure of performance, since users can theoretically upload any amount of money. However, for the purpose of the app, performance should indeed be measured by profitable trades, regardless of the amount of cash involved. In addition, users are provided with the calculation of their performance measure, i.e. realized profits from long positions, realized profits from short positions, and the total cash intake of each user are listed in the ranking. This is also interesting from a technical point of view, as it requires the combination of all the tables we have created in our database. And of course, it is fun to compete!

